<!doctype html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>SwipeLeft test</title>
<style>
body {
  min-height: 100vh;
  margin: 0px;
}
.list {
  width: 100%;
  max-width: 500px;
}
.listItemContainer {
  position: relative;
  width: 100%;
  overflow: hidden;
}
.listItemContent {
  font-size: 36px;
  border: 4px solid gray;
  border-bottom-color: #DDD;
  padding: 4px;
}
</style>
<h1>SwipeLeft test  <====</h1>
<pre>Tested:
- gestures/swipeLeft.js
- effects/swipeLeftButtonMenuEffect.js
- effects/buttonMenu.js
</pre>
<div id="list1" class="list">
</div>
<script type="module">
  // Setup
  for (let i=1;i<=20;++i) {
    // Create list items
    let container = document.createElement("div");
    let content = document.createElement("div");
    container.classList.add("listItemContainer");
    container.append(content);
    content.classList.add("listItemContent");
    content.textContent = `This is a list item ${i}`;
    document.getElementById("list1").append(container);
  }
</script>
<script type="module">
  import GestureManager from "../src/gestureManager.js";
  import SwipeLeft from "../src/gestures/swipeLeft.js";
  import SwipeLeftButtonMenuEffect from "../src/effects/swipeLeftButtonMenuEffect.js";
  import createButtonMenu from  "../src/effects/buttonMenu.js";
  import TestRunner from "./testFramework.js";
  import {LoggerEffect} from "./testUtils.js";

  function getDefaultSwipeLeftMailMenu(container) {
    let nullClickHandler = _ => {};
    return {
      container: container,
      contentSelector: ".listItemContent",
      menuBuilder: createButtonMenu,
      menuBuilderOptions: {
        items: [
          {title: "Moreâ€¦", color: "#c8c7ce", action: nullClickHandler},
          {title: "Flag", color: "#ff9503", action: nullClickHandler},
          {title: "Trash", color: "#ff3a2e",  action: nullClickHandler}
        ]
      }
    };
  }

  function createEvent(type, element, location) {
    let elRect = element.getBoundingClientRect();
  
    let pageX = elRect.x;
    let pageY = elRect.y;
    if (location) {
      if (location.x)
        pageX += location.x;
      if (location.y)
        pageY += location.y;
      if (location.left)
        pageX += location.left;
      if (location.right)
        pageX += elRect.width - location.right;
    }
    let ev = new PointerEvent(type, {
      bubbles: true, 
      timeStamp: 5,
      clientX: pageX - window.scrollX, 
      clientY: pageY - window.scrollY
    });
    return ev;
  }

  async function awaitTimeout(timeout=200) {
    return new Promise((resolve, reject) => {
      window.setTimeout( _ => resolve(), timeout);
    });
  }

  async function awaitSizeStopAnimating(el, timeout=1000) {
    if (el == null)
      return Promise.reject("NULL el passed to awaitSizeStopAnimating");
    let lastWidth;
    let lastHeight;
    let endMillis = Date.now() + timeout;
    return new Promise((resolve, reject) => {
      let interval = window.setInterval( () => {
        if (el.offsetWidth == lastWidth && el.offsetHeight == lastHeight) {
          window.clearInterval(interval);
          resolve();
        }
        if (Date.now() > endMillis) {
          window.clearInterval(interval);
          reject("awaitSizeStopAnimating timed out after " + timeout + "ms");
        }
        lastWidth = el.offsetWidth;
        lastHeight = el.offsetHeight;
      }, 20);
    });
  }


  async function test1() {
    // Permanently install menu
    let container, effect, gesture;
    let itemIndex = 1;
    try {
      const COLOR = "yellow";
      container = document.querySelector(`.list .listItemContainer:nth-child(${itemIndex})`);
      if (container.style.backgroundColor != COLOR) {
        // Only install once
        container.querySelector(".listItemContent").textContent = "Left menu installed";
        let effectOptions = getDefaultSwipeLeftMailMenu(container);
        effect = new SwipeLeftButtonMenuEffect(effectOptions);
        gesture = new SwipeLeft(container, { effect: effect});
        GestureManager.addGesture(container, gesture);
        container.style.backgroundColor = COLOR;
      }
      // Swipe left to open the menu
      container.dispatchEvent(
        createEvent("pointerdown", container, {right: 5})
      );
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 10})
      );
      container.dispatchEvent(
        createEvent("pointerup", container, {right: 200})
      );
    } catch(err) {
      GestureManager.removeGesture(gesture);
      container.style.backgroundColor = "";
      throw err;
    }
  }

  async function test2() {
    // Permanently install menu
    let container, effect, gesture;
    let itemIndex = 2;
    try {
      const COLOR = "yellow";
      container = document.querySelector(`.list .listItemContainer:nth-child(${itemIndex})`);
      if (container.style.backgroundColor != COLOR) {
        // Only install once
        container.querySelector(".listItemContent").textContent = "Left menu with default";
        let effectOptions = getDefaultSwipeLeftMailMenu(container);
        effectOptions.menuBuilderOptions.items[2].default = true;
        effect = new SwipeLeftButtonMenuEffect(effectOptions);
        gesture = new SwipeLeft(container, { effect: effect});
        GestureManager.addGesture(container, gesture);
        container.style.backgroundColor = COLOR;
      }
      // Swipe left to open the menu
      container.dispatchEvent(
        createEvent("pointerdown", container, {right: 5})
      );
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 10})
      );
      container.dispatchEvent(
        createEvent("pointerup", container, {right: 200})
      );
    } catch(err) {
      GestureManager.removeGesture(gesture);
      container.style.backgroundColor = "";
      throw err;
    }
  }

  async function test3() {
    // 1. swipe left so that menu remains visible
    // 2. click on the menu button
    let container, effect, gesture;
    let itemIndex = 3;
    let buttonClicked = false;
    try {
      let action = ev => {
        buttonClicked = ev.currentTarget.textContent;
        effect.clear(); // close the menu
      }
      container = document.querySelector(`.list .listItemContainer:nth-child(${itemIndex})`);
      let effectOptions = getDefaultSwipeLeftMailMenu(container);
      for (let item of effectOptions.menuBuilderOptions.items) {
        item.action = action;
        item.preventClickAutoClose = true;
      }
      effect = new SwipeLeftButtonMenuEffect(effectOptions);
      gesture = new SwipeLeft(container, 
        { effect: effect});
      GestureManager.addGesture(container, gesture);

      // Swipe left
      container.dispatchEvent(
        createEvent("pointerdown", container, {right: 5})
      );
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 10})
      );
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 200})
      );
      container.dispatchEvent(
        createEvent("pointerup", container, {right: 200})
      );
      // Wait till end of animation
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem"));
      // Click on the button
      let button = container.querySelector(".swipeHorizontalMenuItem:nth-child(3)");
      button.dispatchEvent(
        createEvent("click", button, {y: 5, x: 5})
      );
      if (buttonClicked == false)
        throw "Did not click on the button";
      if (buttonClicked != "Trash")
        throw "Clicked on wrong button:" + buttonClicked;
    } catch(err) {
      GestureManager.removeGesture(gesture);
      throw err;
    }
    // Cleanup
    GestureManager.removeGesture(gesture);
  }

  async function test4() {
    // 1. swipe left so that menu remains visible
    // 2. click in empty area, so that menu goes away
    // Setup
    let container, effect, gesture;
    let itemIndex = 4;
    try {
      container = document.querySelector(`.list .listItemContainer:nth-child(${itemIndex})`);
      let effectOptions = getDefaultSwipeLeftMailMenu(container);
      effect = new SwipeLeftButtonMenuEffect(effectOptions);
      gesture = new SwipeLeft(container, 
        { effect: effect});
      GestureManager.addGesture(container, gesture);

      // Test
      // Gesture 1: swipe left.
      container.dispatchEvent(
        createEvent("pointerdown", container, {right: 5})
      );
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 10})
      );
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 200})
      );
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem"));
      container.dispatchEvent(
        createEvent("pointerup", container, {left: 5})
      );
      // Click outside of the button
      container.dispatchEvent(
        createEvent("pointerdown", container, {left: 5})
      );
      container.dispatchEvent(
        createEvent("pointerup", container, {left: 5})
      );
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem"));
    } catch(err) {
      GestureManager.removeGesture(gesture);
      throw err;
    }
    // Cleanup
    GestureManager.removeGesture(gesture);
  }

  async function test5() {
    // Default button that expands
    let container, effect, gesture;
    let itemIndex = 5;
    try {
      container = document.querySelector(`.list .listItemContainer:nth-child(${itemIndex})`);
      let effectOptions = getDefaultSwipeLeftMailMenu(container);
      // Make trash the defult option
      effectOptions.menuBuilderOptions.items[2].default = true;
      effect = new SwipeLeftButtonMenuEffect(effectOptions);
      gesture = new SwipeLeft(container, 
        { effect: effect});
      GestureManager.addGesture(container, gesture);
       // swipe left.
      container.dispatchEvent(
        createEvent("pointerdown", container, {right: 5})
      );
      // first pointermove activates the gesture
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 50})
      );
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 50})
      );
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem:nth-child(3)"));
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 200})
      );
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem:nth-child(3)"));
      // pointermove all the way to the left expands default button
      container.dispatchEvent(
        createEvent("pointermove", container, {left:5})
      );
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem:nth-child(3)"));
      // pointermove to the middle shrinks default button
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 200})
      );
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem:nth-child(3)"));
      container.dispatchEvent(
        createEvent("pointerup", container, {right: 100})
      );
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem:nth-child(3)"));
    } catch(err) {
      GestureManager.removeGesture(gesture);
      throw err;
    }
    // Cleanup
    GestureManager.removeGesture(gesture);
  }

  async function test6() {
    // Default button with action that removes the item
    let container, effect, gesture;
    let itemIndex = 6;
    try {
      container = document.querySelector(`.list .listItemContainer:nth-child(${itemIndex})`);
      let effectOptions = getDefaultSwipeLeftMailMenu(container);
      // Make trash the defult option
      effectOptions.menuBuilderOptions.items[2].default = true;
      effectOptions.menuBuilderOptions.items[2].preventClickAutoClose = true;
      // On click, animate & delete
      effectOptions.menuBuilderOptions.items[2].action = ev => {
        let deleteMe = ev.currentTarget;
        while (deleteMe && !deleteMe.classList.contains("listItemContainer"))
          deleteMe = deleteMe.parentElement;
        if (!deleteMe)
          throw "Could not find container to delete";
        deleteMe.animate([
            {height: `${deleteMe.offsetHeight}px`},
            {height: "0"}
          ], 
          {duration: 200})
          .finished.then( _ => {
            deleteMe.remove();
            effect.clear(); 
          });
      };
      effect = new SwipeLeftButtonMenuEffect(effectOptions);
      gesture = new SwipeLeft(container, 
        { effect: effect});
      GestureManager.addGesture(container, gesture);
       // swipe left.
      container.dispatchEvent(
        createEvent("pointerdown", container, {right: 5})
      );
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 50})
      );
      container.dispatchEvent(
        createEvent("pointermove", container, {right: 50})
      );
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem:nth-child(3)"));
      container.dispatchEvent(
        createEvent("pointermove", container, {left: 5})
      );
      await awaitSizeStopAnimating(container.querySelector(".swipeHorizontalMenuItem:nth-child(3)"));
      container.dispatchEvent(
        createEvent("pointerup", container, {left: 5})
      );
    } catch(err) {
      GestureManager.removeGesture(gesture);
      throw err;
    }
    // Cleanup
    GestureManager.removeGesture(gesture);
  }

  TestRunner.test(test1,  "Install menu on item 1" );
  TestRunner.test(test2,  "Install menu with default" );
  TestRunner.test(test3, "swipe + menu click");
  TestRunner.test(test4, "swipe + blank click");
  TestRunner.test(test5, "swipe + default button");
  TestRunner.test(test6, "swipe + default button deletes");

</script>